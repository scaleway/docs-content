---
meta:
  title: Verifying Servers' Certificate Authority on PostgreSQL
  description: This page explains how to verify a server's certificate authority on Managed Database for PostgreSQL.
content:
  h1: Verifying Servers' Certificate Authority on PostgreSQL
  paragraph: This page explains how to verify a server's certificate authority on Managed Database for PostgreSQL.
tags: verify-ca verify certificate authority postgresql
dates:
  validation: 2022-12-12
  posted: 2022-07-25
categories:
  - managed-databases
---

The creation and management of TLS certificates is included in the Managed Database for PostgreSQL offers.

A TLS certificate is generated automatically for your Database Instance upon its creation.

You can renew your certificates at any time. This allows you to renew your certificates whenever you add a new endpoint, for example.

PostgreSQL natively supports SSL connections that enhance the security of client/server communications with TLS protocols. PostgreSQL does not, however, verify server certificates by default.

In this page we show you two types protection modes you can use to verify if the servers connecting to your client are properly encrypted and if the encryption key matches that of your Database Instance.

We also show you how to run the verification using different languages, such as `psql`, `python`, `go`, and `js`.

<Message type="note">
  The hostnames of Scaleway Database Instances take on the following format: `rw-${instance_id}.rdb.${region}.scw.cloud`.
</Message>

## Using verify-ca

Will verify that a server is trustworthy by checking if the server certificate is valid.

### With psql

```sql
PGSSLROOTCERT=<SSL_CERTIFICATE> psql "host=<IP or HOSTNAME> port=<PORT> user=<USERNAME> sslmode=verify-ca dbname=<DB_NAME>"
```

### With Python

```python
import psycopg2

connectionInfos = {
    'host': <IP or HOSTNAME>,
    'port': <PORT>,
    'user': <USERNAME>,
    'password': <PASSWORD>,
    'sslmode': 'verify-ca',
    'sslrootcert': <PATH_TO_SSL_CERTIFICATE>,
    'dbname': <DB_NAME>
}

try:
    connection = psycopg2.connect(**connectionInfos)
    print("connected successfully")
except psycopg2.Error as e:
    print(e)
```

### With Go

```go
import (
  "database/sql"
  "fmt"

  _ "github.com/lib/pq"
)

const (
  host          = <IP or HOSTNAME>
  port          = <PORT>
  user          = <USERNAME>
  password      = <PASSWORD>
  dbname        = <DB_NAME>
  sslrootcert   = <PATH_TO_SSL_CERTIFICATE>
  sslmode       = 'verify-ca'
)

func main() {
  psqlInfo := fmt.Sprintf("host=%s port=%d user=%s "+
    "password=%s dbname=%s sslmode=%s sslrootcert=%s" ,
    host, port, user, password, dbname, sslmode, sslrootcert)
  db, err := sql.Open("postgres", psqlInfo)
  if err != nil {
    panic(err)
  }
  defer db.Close()

  err = db.Ping()
  if err != nil {
    panic(err)
  }

  fmt.Println("Successfully connected!")
}
```

### With JS

```js
import fs from 'fs'

const config = {
    user: <USERNAME>,
    password: <PASSWORD>,
    database: <DB_NAME>,
    port: <PORT>,
    host: <IP or HOSTNAME>,
    ssl: {
        rejectUnauthorized: false,
        cert: fs.readFileSync(<PATH_TO_SSL_CERTIFICATE>).toString(),
        mode: 'verify-ca'
    },
}
import pkg from 'pg';
const { Client, Pool } = pkg;

const client = new Client(config)
client.connect(err => {
    if (err) {
        console.error('error connecting', err.stack)
    } else {
        console.log('connected')
        client.end()
    }
})

const pool = new Pool(config)
pool
    .connect()
    .then(client => {
        console.log('connected')
        client.release()
    })
    .catch(err => console.error('error connecting', err.stack))
    .then(() => pool.end())
```


## Using verify-full

Will verify that a server is trustworthy by checking if the server certificate is valid and if the hostname specified in the certificate matches the hostname of the server.

### With psql

```sql
PGSSLROOTCERT=<PEM CERTIFICATE> psql "host=rw-${instance_id}.rdb.${region}.scw.cloud port=<PORT> user=<USERNAME> sslmode=verify-full dbname=<DB_NAME>"
```

### With Python

```python
import psycopg2

connectionInfos = {
    'host': <IP or HOSTNAME>,
    'port': <PORT>,
    'user': <USERNAME>,
    'password': <PASSWORD>,
    'sslmode': 'verify-full',
    'sslrootcert': <PATH_TO_SSL_CERTIFICATE>,
    'dbname': <DB_NAME>
}

try:
    connection = psycopg2.connect(**connectionInfos)
    print("connected successfully")
except psycopg2.Error as e:
    print(e)
```

### With Go

```go
import (
    "database/sql"
    "fmt"

    _ "github.com/lib/pq"
)

const (
  host          = <IP or HOSTNAME>
  port          = <PORT>
  user          = <USERNAME>
  password      = <PASSWORD>
  dbname        = <DB_NAME>
  sslrootcert   = <PATH_TO_SSL_CERTIFICATE>
  sslmode        = "verify-full"
)

func main() {
    psqlInfo := fmt.Sprintf("host=%s port=%d user=%s "+
        "password=%s dbname=%s sslrootcert=%s sslmode=%s ",
        host, port, user, password, dbname, sslrootcert, sslmode)
    db, err := sql.Open("postgres", psqlInfo)
    if err != nil {
        panic(err)
    }
    defer db.Close()

    err = db.Ping()
    if err != nil {
        panic(err)
    }

    fmt.Println("Successfully connected!")
}
```

### With JS

```js
import fs from 'fs'

const config = {
    user: <USERNAME>,
    password: <PASSWORD>,
    database: <DB_NAME>,
    port: <PORT>,
    host: <IP or HOSTNAME>,
    ssl: {
        rejectUnauthorized: false,
        cert: fs.readFileSync(<PATH_TO_SSL_CERTIFICATE>).toString(),
        mode: 'verify-full'
    },
}
import pkg from 'pg';
const { Client, Pool } = pkg;

const client = new Client(config)
client.connect(err => {
    if (err) {
        console.error('error connecting', err.stack)
    } else {
        console.log('connected')
        client.end()
    }
})

const pool = new Pool(config)
pool
    .connect()
    .then(client => {
        console.log('connected')
        client.release()
    })
    .catch(err => console.error('error connecting', err.stack))
    .then(() => pool.end())
```